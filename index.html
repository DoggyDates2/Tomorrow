<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map v2.8 - With Fields Support</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            min-height: 60px;
            z-index: 1000;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        input[type="text"] {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: white;
            width: 200px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .group-filters {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .group-filter-btn {
            padding: 6px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            user-select: none;
        }

        .group-filter-btn:hover:not(:disabled) {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .group-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .selection-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            border-left: 2px solid #e1e5e9;
            padding-left: 20px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 80px);
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 999;
            transition: transform 0.3s ease;
        }

        .panel-toggle {
            display: none;
            position: absolute;
            left: 300px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #e1e5e9;
            border-left: none;
            padding: 10px 5px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 0 5px 5px 0;
        }

        @media (max-width: 768px) {
            .left-panel {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                transform: translateX(-100%);
                box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            }
            
            .left-panel.open {
                transform: translateX(0);
            }
            
            .panel-toggle {
                display: block;
                left: 0;
            }
            
            .left-panel.open ~ .panel-toggle {
                left: 300px;
            }
        }

        .legend-section {
            border-bottom: 1px solid #e1e5e9;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
        }

        .legend-section::-webkit-scrollbar {
            width: 6px;
        }

        .legend-section::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .legend-section::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
            border: 1px solid transparent;
            user-select: none;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .legend-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .color-picker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            margin-left: 6px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .color-picker:hover {
            opacity: 1;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }



        .edit-section {
            padding: 8px;
            padding-bottom: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            min-height: 180px;
            max-height: 280px;
            border-top: 1px solid #e1e5e9;
        }

        .no-selection {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin-top: 5px;
            padding: 0 5px;
            font-size: 11px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            margin: 2px;
            user-select: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-clear {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .selection-mode-active {
            background: #fff3cd !important;
            border-color: #ffc107 !important;
            color: #856404 !important;
        }

        .map-container {
            flex: 1;
            position: relative;
            background: #f0f0f0;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
        }

        .leaflet-tile-pane {
            opacity: 1;
        }

        .leaflet-marker-pane {
            opacity: 1 !important;
            filter: none !important;
        }

        .bulk-edit-panel {
            background: #f8f9fa;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .bulk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .bulk-edit-header h4 {
            color: #007bff;
            margin: 0;
        }

        .selected-count {
            background: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .bulk-edit-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .bulk-edit-input {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .bulk-edit-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .selected-dogs-preview {
            max-height: 120px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            margin: 10px 0;
            font-size: 12px;
        }

        .selected-dog-item {
            padding: 2px 0;
            border-bottom: 1px solid #eee;
        }

        .selected-dog-item:last-child {
            border-bottom: none;
        }

        .marker-selected {
            filter: drop-shadow(0 0 10px #007bff) brightness(1.2);
            transform: scale(1.2);
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #333;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 9999;
            animation: slideInRight 0.3s ease;
            max-width: 350px;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .notification-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .notification-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .notification-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            font-size: 14px;
        }

        .save-indicator.saving {
            background: #fff3cd;
            color: #856404;
        }

        .save-indicator.saved {
            background: #d4edda;
            color: #155724;
        }

        .save-indicator.error {
            background: #f8d7da;
            color: #721c24;
        }

        .custom-tooltip {
            background: rgba(0, 0, 0, 0.9) !important;
            border: 1px solid #333 !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 16px !important;
            padding: 8px 12px !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4) !important;
            white-space: normal !important;
            max-width: 250px !important;
            text-align: center !important;
            line-height: 1.4 !important;
        }
        
        .leaflet-tooltip-top:before {
            border-top-color: rgba(0, 0, 0, 0.9) !important;
        }

        .connection-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none;
            align-items: center;
            gap: 6px;
            z-index: 1000;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .error-message {
            color: #dc3545;
            font-style: italic;
            padding: 10px;
            text-align: center;
        }

        .version-indicator {
            margin-left: auto;
            padding: 0 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .today-text {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .column-info {
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }

        .field-marker-tooltip {
            background: rgba(0, 0, 0, 0.95) !important;
            border: 2px solid #666 !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 14px !important;
            padding: 6px 10px !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4) !important;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="searchInput">Search:</label>
            <input type="text" id="searchInput" placeholder="Search dogs, drivers, or addresses..." autocomplete="off" />
        </div>

        <div class="control-group group-filters">
            <button class="group-filter-btn active" data-group="1" id="group1Btn">Group 1 ‚≠ï</button>
            <button class="group-filter-btn active" data-group="2" id="group2Btn">Group 2 ‚ñ≤</button>
            <button class="group-filter-btn active" data-group="3" id="group3Btn">Group 3 ‚ñ†</button>
        </div>

        <div class="selection-controls">
            <button class="btn btn-warning" id="selectionModeBtn">üéØ Select Mode</button>
            <button class="btn btn-danger" id="clearSelectionBtn" style="display: none;">‚úñÔ∏è Clear Selection</button>
        </div>

        <div class="control-group">
            <button class="btn btn-secondary" id="resetColorsBtn">üé® Reset Colors</button>
            <button class="btn btn-info" id="testConnectionBtn">üîå Test Connection</button>
        </div>
        
        <div class="version-indicator">
            <span class="today-text">TOMORROW</span>
            <span class="column-info" id="columnInfo">Loading...</span>
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel" id="leftPanel">
            <div class="legend-section">
                <div style="text-align: center; margin-bottom: 6px;">
                    <button class="btn btn-clear" id="showAllBtn" style="width: 100%; padding: 6px 8px; font-size: 12px;">Show All</button>
                </div>
                
                <h3>Drivers</h3>
                <div id="legendContent">Loading...</div>
            </div>
            
            <div class="edit-section">
                <div id="bulkEditPanel" style="display: none;"></div>
                <div id="detailsContent" class="no-selection">
                    Click a marker to edit
                </div>
            </div>
        </div>
        
        <button class="panel-toggle" id="panelToggle">
            <span id="panelToggleIcon">‚óÄ</span>
        </button>

        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <div id="saveIndicator" class="save-indicator" style="display: none;">
        <span class="spinner"></span>
        <span>Saving...</span>
    </div>

    <div id="connectionStatus" class="connection-status" style="display: none;">
        <span>Sheet Connection</span>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <script>
        'use strict';

        // ==================== CONFIGURATION ====================
        const CONFIG = Object.freeze({
            SHEET_ID: '1a3xyQvgTqybhQucjsq-g24g4GAnGqV3fOOZktVt9VhU',
            WORKSHEET_NAME: 'Schedule',
            FIELDS_WORKSHEET_NAME: 'Fields', // New fields tab
            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',
            APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbyAIZavcGcPhKH8WC6Ynop5NESF5sE2eyePubRoqebSbj3sbPxr4BMp-eYD81-th7cstQ/exec',
            DEFAULT_LAT: 42.2968,
            DEFAULT_LNG: -71.2636,
            DEFAULT_ZOOM: 11,
            DEBOUNCE_DELAY: 300,
            MAX_MARKERS: 10000,
            MAX_SELECTION: 500,
            DATE_COLUMN_FORMAT: 'M/D/YYYY',
            FALLBACK_COLUMN: 'Combined'
        });

        // Master color palette
        const ALL_COLORS = Object.freeze([
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#ff9896', '#98df8a', '#c5b0d5', '#c49c94', '#f7b6d3', '#c7c7c7',
            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF',
            '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0097E6', '#8C7AE6', '#F79F1F',
            '#A3CB38', '#E74C3C', '#3742FA', '#2F3542', '#FF3838', '#2ECC71', '#9B59B6', '#E67E22',
            '#1ABC9C', '#34495E', '#F39C12', '#E91E63', '#00BCD4', '#607D8B', '#795548', '#009688',
            '#FF5722', '#673AB7', '#3F51B5', '#2196F3', '#03DAC6', '#6200EA', '#FF4081', '#FFAB00',
            '#00E676', '#DD2C00', '#651FFF', '#FF6D00', '#FF1744', '#00E5FF', '#BF360C', '#1B5E20'
        ]);

        // ==================== STATE MANAGEMENT ====================
        const state = {
            map: null,
            markers: [],
            fieldMarkers: [], // New: separate array for field markers
            markerLookup: new Map(),
            coordinateLookup: new Map(),
            allData: [],
            fieldsData: [], // New: data from Fields tab
            filteredData: [],
            colorMap: {},
            selectedMarker: null,
            selectedRow: null,
            currentFilter: null,
            driverColorMap: {},
            customColors: {},
            activeGroups: [1, 2, 3],
            selectionMode: false,
            selectedMarkers: new Set(),
            drawControl: null,
            drawnItems: null,
            isUpdating: false,
            pendingSaves: new Map(),
            saveQueue: [],
            isSaving: false,
            activeColumn: null,
            dateColumnFound: false
        };

        // ==================== UTILITY FUNCTIONS ====================
        
        // Get today's date in various formats to match spreadsheet columns
        function getTodayFormats() {
            const today = new Date();
            today.setDate(today.getDate() + 1); // ADD THIS LINE - makes it tomorrow
            const month = today.getMonth() + 1;
            const day = today.getDate();
            const year = today.getFullYear();
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const fullMonthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                   'July', 'August', 'September', 'October', 'November', 'December'];
            const monthName = monthNames[today.getMonth()];
            const fullMonthName = fullMonthNames[today.getMonth()];
            
            return [
                `${monthName} ${day}`,
                `${fullMonthName} ${day}`,
                `${monthName} ${day}, ${year}`,
                `${fullMonthName} ${day}, ${year}`,
                `${day} ${monthName}`,
                `${day} ${fullMonthName}`,
                `${month}/${day}/${year}`,
                `${month}/${day}/${String(year).slice(-2)}`,
                `${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}/${year}`,
                `${String(month).padStart(2, '0')}/${String(day).padStart(2, '0')}/${String(year).slice(-2)}`,
                `${month}-${day}-${year}`,
                `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`,
                getDayName(today.getDay()) + ` ${monthName} ${day}`,
                getDayName(today.getDay()) + ` ${month}/${day}`,
                getDayName(today.getDay()),
            ];
        }
        
        function getDayName(dayIndex) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days[dayIndex];
        }
        
        // Find the column that matches today's date
        function findDateColumn(headers) {
            const todayFormats = getTodayFormats();
            
            console.log('Looking for today\'s date columns:', todayFormats);
            
            for (const format of todayFormats) {
                const index = headers.indexOf(format);
                if (index !== -1) {
                    console.log(`Found exact date column: "${format}" at index ${index}`);
                    return { columnName: format, index: index };
                }
            }
            
            for (const format of todayFormats) {
                const index = headers.findIndex(h => 
                    h && h.toString().trim().toLowerCase() === format.toLowerCase()
                );
                if (index !== -1) {
                    console.log(`Found date column (case-insensitive): "${headers[index]}" at index ${index}`);
                    return { columnName: headers[index], index: index };
                }
            }
            
            for (const format of todayFormats) {
                const index = headers.findIndex(h => 
                    h && h.toString().includes(format)
                );
                if (index !== -1) {
                    console.log(`Found date column (partial match): "${headers[index]}" at index ${index}`);
                    return { columnName: headers[index], index: index };
                }
            }
            
            const fallbackIndex = headers.indexOf(CONFIG.FALLBACK_COLUMN);
            if (fallbackIndex !== -1) {
                console.log(`Date column not found, using fallback: "${CONFIG.FALLBACK_COLUMN}"`);
                return { columnName: CONFIG.FALLBACK_COLUMN, index: fallbackIndex, isFallback: true };
            }
            
            console.warn('No date column or fallback column found');
            return null;
        }
        
        function showNotification(message, type = 'info', duration = 3000) {
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.animation = 'fadeOut 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        function validateCoordinates(lat, lng) {
            const latNum = Number(lat);
            const lngNum = Number(lng);
            
            if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {
                return false;
            }
            
            if (latNum < -90 || latNum > 90 || lngNum < -180 || lngNum > 180) {
                return false;
            }
            
            if (Math.abs(latNum) < 0.0001 && Math.abs(lngNum) < 0.0001) {
                return false;
            }
            
            return true;
        }

        // Parse combined field to extract driver and group
        function parseCombined(combinedValue) {
            if (!combinedValue) return { driver: '', group: null };
            
            const str = String(combinedValue).trim();
            if (!str) return { driver: '', group: null };
            
            const lastColonIndex = str.lastIndexOf(':');
            
            if (lastColonIndex === -1) {
                return { driver: str, group: null };
            }
            
            const driver = str.substring(0, lastColonIndex).trim();
            const groupStr = str.substring(lastColonIndex + 1).trim();
            const group = parseGroup(groupStr);
            
            return { driver, group };
        }
        
        // Parse group from a group string
        function parseGroup(groupValue) {
            if (!groupValue) return null;
            
            const originalValue = String(groupValue).trim();
            let strValue = originalValue;
            if (!strValue) return null;
            
            if (strValue.includes('&')) {
                const parts = strValue.split('&').map(part => {
                    return part.replace(/DD|SUB|AA|F|XX/g, '').trim();
                });
                strValue = parts.join('&');
            } else {
                strValue = strValue.replace(/(\d)(DD|SUB|AA|F|XX)(\d)/g, '$1$3');
                strValue = strValue.replace(/(\d)(DD|SUB|AA|F|XX)$/g, '$1');
            }
            
            if (strValue.match(/^([123])\1$/)) {
                return parseInt(strValue[0], 10);
            }
            
            if (strValue.includes('&')) {
                const groups = strValue.split('&')
                    .map(g => g.trim())
                    .filter(g => g.match(/^[123]$/))
                    .sort();
                if (groups.length === 2) {
                    const joined = groups.join('');
                    if (joined === '12' || joined === '23') {
                        return joined;
                    }
                    if (joined === '13') {
                        return '123';
                    }
                } else if (groups.length === 1) {
                    return parseInt(groups[0], 10);
                }
            }
            
            if (strValue.match(/^[123]{2,3}$/)) {
                const uniqueGroups = [...new Set(strValue.split(''))].sort().join('');
                if (uniqueGroups === '13') {
                    return '123';
                }
                return uniqueGroups;
            }
            
            if (strValue.match(/^[123]$/)) {
                return parseInt(strValue, 10);
            }
            
            return null;
        }

        // Get unique dog ID
        function getDogId(row) {
            if (!row) return null;
            
            if (row['_uniqueId']) {
                return row['_uniqueId'];
            }
            
            let id = null;
            
            if (row['Dog ID'] && row['Dog ID'].trim()) {
                id = row['Dog ID'].trim();
            } else if (row['Dog Name'] && row['Dog Name'].trim()) {
                id = row['Dog Name'].trim();
                const index = row['_rowIndex'] ?? state.allData.indexOf(row);
                if (index >= 0) {
                    id = `${id}_${index}`;
                }
            } else {
                const index = row['_rowIndex'] ?? state.allData.indexOf(row);
                id = `dog_${index >= 0 ? index : Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            row['_uniqueId'] = id;
            return id;
        }

        // Get row's sheet index (accounting for header row)
        function getSheetRowIndex(row) {
            if (row && typeof row['_rowIndex'] === 'number') {
                return row['_rowIndex'] + 2;
            }
            
            const index = state.allData.indexOf(row);
            if (index !== -1) {
                return index + 2;
            }
            
            console.error('Could not determine sheet row index for row:', row);
            return -1;
        }

        // Point in polygon algorithm
        function isPointInPolygon(point, polygon) {
            if (!polygon || polygon.length < 3) return false;
            if (!point || !Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return false;
            
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (!Number.isFinite(xi) || !Number.isFinite(yi) || 
                    !Number.isFinite(xj) || !Number.isFinite(yj)) {
                    continue;
                }
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }

        // ==================== APPS SCRIPT COMMUNICATION ====================
        async function callAppsScript(payload) {
            try {
                const response = await fetch(CONFIG.APPS_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: JSON.stringify(payload)
                });
                
                return { success: true };
                
            } catch (error) {
                console.error('Error calling Apps Script:', error);
                throw error;
            }
        }

        async function testAppsScriptConnection() {
            try {
                console.log('Testing Apps Script connection to:', CONFIG.APPS_SCRIPT_URL);
                
                const statusEl = document.getElementById('connectionStatus');
                if (statusEl) {
                    statusEl.style.display = 'flex';
                    statusEl.className = 'connection-status';
                    statusEl.innerHTML = '<span class="spinner"></span><span>Testing connection...</span>';
                }
                
                const response = await fetch(CONFIG.APPS_SCRIPT_URL);
                const text = await response.text();
                
                if (text.includes('Standalone Dog Walking Map Script')) {
                    showNotification('‚úÖ Google Sheets connection verified!', 'success');
                    console.log('Apps Script GET response:', text);
                    
                    if (statusEl) {
                        statusEl.className = 'connection-status connected';
                        statusEl.innerHTML = '‚úÖ Sheet Connected';
                        setTimeout(() => {
                            statusEl.style.display = 'none';
                        }, 3000);
                    }
                    
                    return true;
                } else {
                    showNotification('‚ö†Ô∏è Apps Script found but response unexpected', 'warning');
                    console.log('Unexpected response:', text);
                    
                    if (statusEl) {
                        statusEl.className = 'connection-status disconnected';
                        statusEl.innerHTML = '‚ö†Ô∏è Connection Issue';
                    }
                    
                    return false;
                }
            } catch (error) {
                console.error('Apps Script test failed:', error);
                showNotification('‚ö†Ô∏è Could not connect to Google Sheets', 'error');
                
                const statusEl = document.getElementById('connectionStatus');
                if (statusEl) {
                    statusEl.className = 'connection-status disconnected';
                    statusEl.innerHTML = '‚ùå Not Connected';
                }
                
                return false;
            }
        }

        // ==================== COLOR MANAGEMENT ====================
        function assignDriverColors() {
            if (!state.allData || state.allData.length === 0 || !state.activeColumn) {
                state.driverColorMap = {};
                return;
            }
            
            const drivers = new Set();
            
            state.allData.forEach(row => {
                if (row && row[state.activeColumn]) {
                    const columnValue = row[state.activeColumn].trim();
                    
                    if (!columnValue || columnValue === '') return;
                    const columnValueLower = columnValue.toLowerCase();
                    if (columnValueLower === 'cancel' || 
                        columnValueLower === 'lmcancel' || 
                        columnValueLower === 'lm cancel' ||
                        columnValueLower === 'cancelled' ||
                        columnValueLower === 'lm cancelled') return;
                    
                    const { driver } = parseCombined(columnValue);
                    if (driver) {
                        drivers.add(driver);
                    }
                }
            });
            
            const sortedDrivers = Array.from(drivers).sort();
            const newColorMap = {};
            
            sortedDrivers.forEach((driver, index) => {
                if (state.customColors[driver]) {
                    newColorMap[driver] = state.customColors[driver];
                } else if (state.driverColorMap[driver]) {
                    newColorMap[driver] = state.driverColorMap[driver];
                } else if (index < ALL_COLORS.length) {
                    newColorMap[driver] = ALL_COLORS[index];
                } else {
                    let hash = 0;
                    for (let i = 0; i < driver.length; i++) {
                        hash = ((hash << 5) - hash) + driver.charCodeAt(i);
                        hash = hash & hash;
                    }
                    const hue = Math.abs(hash) % 360;
                    newColorMap[driver] = `hsl(${hue}, 70%, 50%)`;
                }
            });
            
            state.driverColorMap = newColorMap;
            console.log('Assigned colors to', sortedDrivers.length, 'drivers');
        }

        function getDriverColor(name) {
            if (!name || name.trim() === '') return '#999999';
            const trimmedName = name.trim();
            
            if (trimmedName.toLowerCase().includes('unassigned')) {
                return '#000000';
            }
            
            if (state.customColors[trimmedName]) return state.customColors[trimmedName];
            return state.driverColorMap[trimmedName] || '#999999';
        }

        function changeCustomColor(categoryName, newColor) {
            console.log('Changing color for:', categoryName, 'to:', newColor);
            state.customColors[categoryName] = newColor;
            assignDriverColors();
            updateMap();
            showNotification(`Color updated for ${categoryName}`, 'success', 2000);
        }

        // ==================== MARKER CREATION ====================
        function createFieldDiamondIcon() {
            const size = 24;
            const strokeColor = '#666666';
            const strokeWidth = 2;
            const fillColor = '#000000';
            
            return L.divIcon({
                html: `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));">
                    <path d="M${size/2} 2 L${size-2} ${size/2} L${size/2} ${size-2} L2 ${size/2} Z" 
                          fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                </svg>`,
                className: 'custom-field-diamond-marker',
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }
        
        function createMarkerIcon(color, isSelected = false, markerType = 'circle', group = null, isInSelection = false, dogName = null, hasCallout = false) {
            // Special handling for Park (white diamond) - keep this for backward compatibility
            if (dogName && dogName.toLowerCase() === 'park') {
                const strokeColor = isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#666666');
                const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
                const size = isInSelection ? 28 : 24;
                const fillColor = '#FFFFFF';
                
                return L.divIcon({
                    html: `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                        <path d="M${size/2} 2 L${size-2} ${size/2} L${size/2} ${size-2} L2 ${size/2} Z" 
                              fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                    </svg>`,
                    className: `custom-diamond-marker ${isInSelection ? 'marker-selected' : ''}`,
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            }
            
            color = color || '#999999';
            const strokeColor = hasCallout ? '#ff0000' : (isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#000000'));
            const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
            const size = isInSelection ? 16 : 13;
            
            let icon;
            
            try {
                if (group === 2) {
                    // Triangle for Group 2
                    const svgSize = size + 3;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M${svgSize/2} 2 L${svgSize-2} ${svgSize-2} L2 ${svgSize-2} Z" 
                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-triangle-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === 3) {
                    // Square for Group 3
                    icon = L.divIcon({
                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                        className: `custom-square-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                } else if (group === '12') {
                    // Star for Group 1&2
                    const svgSize = size + 4;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <polygon points="${svgSize/2},2 ${svgSize*0.6},${svgSize*0.4} ${svgSize-2},${svgSize*0.4} ${svgSize*0.7},${svgSize*0.6} ${svgSize*0.8},${svgSize-2} ${svgSize/2},${svgSize*0.75} ${svgSize*0.2},${svgSize-2} ${svgSize*0.3},${svgSize*0.6} 2,${svgSize*0.4} ${svgSize*0.4},${svgSize*0.4}" 
                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-star-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === '23') {
                    // Trapezoid for Group 2&3
                    const svgSize = size + 4;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M3 2 L${svgSize-3} 2 L${svgSize-5} ${svgSize-2} L5 ${svgSize-2} Z" 
                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-trapezoid-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === '123') {
                    // Hexagon for Group 1&2&3
                    const svgSize = size + 4;
                    const cx = svgSize/2;
                    const cy = svgSize/2;
                    const r = (svgSize-4)/2;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <polygon points="${cx+r},${cy} ${cx+r/2},${cy-r*0.866} ${cx-r/2},${cy-r*0.866} ${cx-r},${cy} ${cx-r/2},${cy+r*0.866} ${cx+r/2},${cy+r*0.866}" 
                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-hexagon-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else {
                    // Circle for Group 1 (default)
                    icon = L.divIcon({
                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                        className: `custom-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                }
                
                return icon;
                
            } catch (error) {
                console.error('Error creating marker icon:', error);
                return L.divIcon({
                    html: `<div style="width: 13px; height: 13px; background-color: #999999; border: 2px solid #000000; border-radius: 50%;"></div>`,
                    className: 'custom-marker-fallback',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
            }
        }

        // ==================== MAP INITIALIZATION ====================
        function initMap() {
            try {
                console.log('Initializing map...');
                
                if (typeof L === 'undefined') {
                    throw new Error('Leaflet library not loaded');
                }
                
                state.map = L.map('map', {
                    center: [CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG],
                    zoom: CONFIG.DEFAULT_ZOOM,
                    preferCanvas: true,
                    zoomControl: true,
                    attributionControl: true
                });
                
                const tileUrl = 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png';
                
                console.log('Loading map tiles: Stamen Toner (High contrast for clear streets)');
                
                const tileLayer = L.tileLayer(tileUrl, {
                    attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',
                    maxZoom: 19,
                    minZoom: 2,
                    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
                });
                
                let fallbackLayer = null;
                let tileLoadTimeout = null;
                
                tileLoadTimeout = setTimeout(() => {
                    const tiles = document.querySelectorAll('.leaflet-tile');
                    if (tiles.length === 0 && !fallbackLayer) {
                        console.warn('No tiles loaded - switching to fallback');
                        showNotification('Stamen server not responding, trying fallback...', 'info');
                        
                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                            maxZoom: 19
                        });
                        state.map.removeLayer(tileLayer);
                        fallbackLayer.addTo(state.map);
                    }
                }, 5000);
                
                tileLayer.on('tileerror', function(error) {
                    console.error('Tile load error:', error);
                    if (tileLoadTimeout) {
                        clearTimeout(tileLoadTimeout);
                        tileLoadTimeout = null;
                    }
                    
                    if (!fallbackLayer) {
                        console.log('Switching to fallback map provider (CartoDB Positron)...');
                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                            maxZoom: 19
                        });
                        state.map.removeLayer(tileLayer);
                        fallbackLayer.addTo(state.map);
                        showNotification('Using fallback map tiles', 'info');
                    }
                });
                
                tileLayer.on('tileload', function() {
                    if (tileLoadTimeout) {
                        clearTimeout(tileLoadTimeout);
                        tileLoadTimeout = null;
                    }
                });
                
                tileLayer.addTo(state.map);
                
                setTimeout(() => {
                    const tiles = document.querySelectorAll('.leaflet-tile');
                    const loadedTiles = document.querySelectorAll('.leaflet-tile-loaded');
                    if (tiles.length === 0) {
                        console.warn('No tiles found - map provider may be down');
                        console.warn('Current tile URL pattern:', tileUrl);
                        showNotification('Map tiles not loading - check console for details', 'error');
                    } else {
                        console.log(`Map tiles status: ${tiles.length} total, ${loadedTiles.length} loaded`);
                        if (loadedTiles.length === 0) {
                            console.warn('Tiles found but none loaded - possible network issue');
                        }
                    }
                }, 3000);
                
                state.map.on('error', function(e) {
                    console.error('Map error:', e);
                });

                console.log('Map initialized successfully');
                
            } catch (error) {
                console.error('Error initializing map:', error);
                showNotification('Failed to initialize map. Please refresh the page.', 'error', 0);
            }
        }

        // ==================== LOAD FIELDS DATA ====================
        async function loadFieldsData() {
            try {
                if (!CONFIG.SHEET_ID || !CONFIG.API_KEY) {
                    console.log('No fields data - Sheet ID or API key not configured');
                    return;
                }
                
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.FIELDS_WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                
                console.log(`Loading fields data from tab: "${CONFIG.FIELDS_WORKSHEET_NAME}"`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log('Fields tab not found - this is optional');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data || !data.values || data.values.length < 2) {
                    console.log('No data in Fields tab');
                    return;
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                console.log('Fields tab headers:', headers);
                
                // Validate required columns
                const requiredColumns = ['Field Name', 'Latitude', 'Longitude'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                
                if (missingColumns.length > 0) {
                    console.warn(`Fields tab missing columns: ${missingColumns.join(', ')}`);
                    return;
                }
                
                // Process fields data
                const processedFields = [];
                let validFields = 0;
                
                rows.forEach((row, index) => {
                    try {
                        const obj = {};
                        headers.forEach((header, headerIndex) => {
                            obj[header] = row[headerIndex] || '';
                        });
                        
                        if (!obj['Field Name'] || obj['Field Name'].trim() === '') {
                            return;
                        }
                        
                        const lat = parseFloat(obj['Latitude']);
                        const lng = parseFloat(obj['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) {
                            return;
                        }
                        
                        obj['_lat'] = lat;
                        obj['_lng'] = lng;
                        
                        processedFields.push(obj);
                        validFields++;
                        
                    } catch (rowError) {
                        console.warn(`Error processing field row ${index + 2}:`, rowError);
                    }
                });
                
                state.fieldsData = processedFields;
                
                if (validFields > 0) {
                    console.log(`Loaded ${validFields} field locations`);
                    updateFieldsDisplay();
                    addFieldMarkers();
                }
                
            } catch (error) {
                console.error('Error loading fields data:', error);
                // This is optional data, so don't show error to user
            }
        }

        // ==================== ADD FIELD MARKERS ====================
        function addFieldMarkers() {
            // Clear existing field markers
            state.fieldMarkers.forEach(marker => {
                if (marker && state.map.hasLayer(marker)) {
                    state.map.removeLayer(marker);
                }
            });
            state.fieldMarkers = [];
            
            if (!state.fieldsData || state.fieldsData.length === 0) {
                return;
            }
            
            state.fieldsData.forEach(field => {
                try {
                    const lat = field['_lat'] ?? parseFloat(field['Latitude']);
                    const lng = field['_lng'] ?? parseFloat(field['Longitude']);
                    
                    if (!validateCoordinates(lat, lng)) return;
                    
                    const marker = L.marker([lat, lng], {
                        icon: createFieldDiamondIcon(),
                        riseOnHover: true
                    });
                    
                    // Create tooltip for field
                    const fieldName = field['Field Name'] || 'Unknown Field';
                    const notes = field['Notes'] || '';
                    
                    let tooltipHtml = `<div style="text-align: center;"><strong>${escapeHtml(fieldName)}</strong>`;
                    if (notes) {
                        tooltipHtml += `<br/><span style="font-style: italic;">${escapeHtml(notes)}</span>`;
                    }
                    tooltipHtml += `</div>`;
                    
                    marker.bindTooltip(tooltipHtml, {
                        permanent: false,
                        direction: 'top',
                        offset: [0, -12],
                        className: 'field-marker-tooltip',
                        opacity: 0.95
                    });
                    
                    // Add marker to map
                    marker.addTo(state.map);
                    
                    // Field markers are not editable, so no click handler for editing
                    
                    state.fieldMarkers.push(marker);
                    
                } catch (error) {
                    console.warn('Error creating field marker:', error);
                }
            });
        }

        // ==================== UPDATE FIELDS DISPLAY ====================
        function updateFieldsDisplay() {
            const fieldsSection = document.getElementById('fieldsSection');
            const fieldsContent = document.getElementById('fieldsContent');
            
            if (!fieldsSection || !fieldsContent) return;
            
            if (state.fieldsData && state.fieldsData.length > 0) {
                fieldsSection.style.display = 'block';
                
                const fieldsHtml = state.fieldsData.map(field => {
                    const fieldName = escapeHtml(field['Field Name'] || 'Unknown');
                    return `<div class="field-item">
                        <div class="field-diamond"></div>
                        <span>${fieldName}</span>
                    </div>`;
                }).join('');
                
                fieldsContent.innerHTML = fieldsHtml || '<div class="no-selection">No fields found</div>';
            } else {
                fieldsSection.style.display = 'none';
            }
        }

        // ==================== DATA LOADING ====================
        async function loadData() {
            showNotification('Loading data from Google Sheets...', 'info');
            
            try {
                if (!CONFIG.SHEET_ID || !CONFIG.API_KEY) {
                    throw new Error('Sheet ID or API key not configured');
                }
                
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                
                console.log(`Loading data from sheet: "${CONFIG.WORKSHEET_NAME}"`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        throw new Error('Access denied - check API key permissions');
                    } else if (response.status === 404) {
                        throw new Error(`Sheet not found - verify worksheet name "${CONFIG.WORKSHEET_NAME}"`);
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                }
                
                const data = await response.json();
                
                if (!data || !data.values || data.values.length < 2) {
                    throw new Error('No data found in sheet');
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                console.log('Headers from Google Sheet:', headers);
                
                // Find today's date column or fallback
                const dateColumnInfo = findDateColumn(headers);
                
                if (!dateColumnInfo) {
                    throw new Error('No date column found for today and no fallback column available');
                }
                
                state.activeColumn = dateColumnInfo.columnName;
                state.dateColumnFound = !dateColumnInfo.isFallback;
                
                // Show which column we're using
                if (dateColumnInfo.isFallback) {
                    showNotification(`Using fallback column: ${state.activeColumn}`, 'warning');
                } else {
                    showNotification(`Using today's schedule: ${state.activeColumn}`, 'success');
                }
                
                // Update the UI to show which column is active
                const columnInfo = document.getElementById('columnInfo');
                if (columnInfo) {
                    columnInfo.textContent = state.activeColumn;
                }
                
                // Validate required columns
                const requiredColumns = ['Dog Name', 'Latitude', 'Longitude'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                
                if (missingColumns.length > 0) {
                    console.warn(`Missing columns: ${missingColumns.join(', ')}`);
                }
                
                // Process data
                const processedData = [];
                let validRows = 0;
                const invalidRows = [];
                let cancelledCount = 0;
                let blankCount = 0;
                
                rows.forEach((row, index) => {
                    try {
                        const obj = {};
                        headers.forEach((header, headerIndex) => {
                            obj[header] = row[headerIndex] || '';
                        });
                        
                        if (!obj['Dog Name'] || obj['Dog Name'].trim() === '') {
                            invalidRows.push(index + 2);
                            return;
                        }
                        
                        const lat = parseFloat(obj['Latitude']);
                        const lng = parseFloat(obj['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) {
                            invalidRows.push(index + 2);
                            return;
                        }
                        
                        // Check for cancelled or blank entries in the active column
                        if (state.activeColumn && obj[state.activeColumn]) {
                            const columnValue = obj[state.activeColumn].trim();
                            if (!columnValue || columnValue === '') {
                                blankCount++;
                            } else {
                                const columnValueLower = columnValue.toLowerCase();
                                if (columnValueLower === 'cancel' || 
                                    columnValueLower === 'lmcancel' || 
                                    columnValueLower === 'lm cancel' ||
                                    columnValueLower === 'cancelled' ||
                                    columnValueLower === 'lm cancelled') {
                                    cancelledCount++;
                                }
                            }
                        } else if (state.activeColumn) {
                            blankCount++;
                        }
                        
                        obj['_lat'] = lat;
                        obj['_lng'] = lng;
                        obj['_rowIndex'] = index;
                        
                        processedData.push(obj);
                        validRows++;
                        
                    } catch (rowError) {
                        console.warn(`Error processing row ${index + 2}:`, rowError);
                        invalidRows.push(index + 2);
                    }
                });
                
                if (validRows === 0) {
                    throw new Error('No valid data rows found');
                }
                
                state.allData = processedData;
                state.markerLookup.clear();
                state.coordinateLookup.clear();
                
                let message = `Loaded ${validRows} locations`;
                if (cancelledCount > 0) {
                    message += ` (${cancelledCount} cancelled)`;
                }
                if (blankCount > 0) {
                    message += ` (${blankCount} unassigned)`;
                }
                if (invalidRows.length > 0) {
                    const showRows = invalidRows.slice(0, 5);
                    const moreText = invalidRows.length > 5 ? ` and ${invalidRows.length - 5} more` : '';
                    message += ` (Invalid rows: ${showRows.join(', ')}${moreText})`;
                }
                showNotification(message, 'success');
                
                assignDriverColors();
                updateMap();
                
                // Load fields data after main data
                loadFieldsData();
                
            } catch (error) {
                console.error('Data loading error:', error);
                showNotification('Error loading data: ' + error.message, 'error');
                
                state.allData = [];
                state.markers = [];
                state.filteredData = [];
                state.markerLookup.clear();
                state.coordinateLookup.clear();
            }
        }

        // ==================== MAP UPDATE ====================
        function updateMap() {
            try {
                // Clear existing markers (but not field markers)
                state.markers.forEach(m => {
                    if (m && m.marker) {
                        try {
                            m.marker.off();
                            if (state.map.hasLayer(m.marker)) {
                                state.map.removeLayer(m.marker);
                            }
                        } catch (e) {
                            console.warn('Error removing marker:', e);
                        }
                    }
                });
                state.markers = [];
                state.coordinateLookup.clear();

                const searchInput = document.getElementById('searchInput');
                const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

                if (!state.allData || state.allData.length === 0) {
                    updateLegend();
                    return;
                }

                // Filter data
                state.filteredData = state.allData.filter(row => {
                    if (!row) return false;
                    
                    const columnValue = state.activeColumn ? row[state.activeColumn] : '';
                    if (!columnValue || columnValue.trim() === '') {
                        return false;
                    }
                    
                    const columnValueLower = columnValue.toLowerCase().trim();
                    if (columnValueLower === 'cancel' || 
                        columnValueLower === 'lmcancel' || 
                        columnValueLower === 'lm cancel' ||
                        columnValueLower === 'cancelled' ||
                        columnValueLower === 'lm cancelled') {
                        return false;
                    }
                    
                    const { driver, group } = parseCombined(columnValue);
                    
                    // Search filter
                    if (searchTerm) {
                        const searchFields = [
                            row['Dog Name'],
                            row['Address'],
                            driver,
                            row['Callout'],
                            row['Dog ID']
                        ].filter(Boolean).join(' ').toLowerCase();
                        
                        if (!searchFields.includes(searchTerm)) {
                            return false;
                        }
                    }
                    
                    // Group filter
                    if (group !== null) {
                        if (typeof group === 'string' && group.length > 1) {
                            const hasActiveGroup = group.split('').some(g => state.activeGroups.includes(parseInt(g)));
                            if (!hasActiveGroup) {
                                return false;
                            }
                        } else if (typeof group === 'number') {
                            if (!state.activeGroups.includes(group)) {
                                return false;
                            }
                        }
                    } else {
                        if (state.activeGroups.length < 3) {
                            return false;
                        }
                    }
                    
                    // Driver filter
                    if (state.currentFilter !== null) {
                        if (driver !== state.currentFilter) {
                            return false;
                        }
                    }
                    
                    return true;
                });

                // Build color map for drivers
                state.colorMap = {};
                state.allData.forEach(row => {
                    if (row && state.activeColumn && row[state.activeColumn]) {
                        const columnValue = row[state.activeColumn].trim();
                        
                        if (!columnValue || columnValue === '') return;
                        const columnValueLower = columnValue.toLowerCase();
                        if (columnValueLower === 'cancel' || 
                            columnValueLower === 'lmcancel' || 
                            columnValueLower === 'lm cancel' ||
                            columnValueLower === 'cancelled' ||
                            columnValueLower === 'lm cancelled') return;
                        
                        const { driver } = parseCombined(columnValue);
                        if (driver) {
                            state.colorMap[driver] = getDriverColor(driver);
                        }
                    }
                });

                // Create markers
                state.filteredData.forEach(row => {
                    if (!row) return;
                    
                    try {
                        const lat = row['_lat'] ?? parseFloat(row['Latitude']);
                        const lng = row['_lng'] ?? parseFloat(row['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) return;
                        
                        // Handle overlapping coordinates
                        const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                        const existingCount = state.coordinateLookup.get(coordKey) || 0;
                        state.coordinateLookup.set(coordKey, existingCount + 1);
                        
                        const offsetLat = existingCount > 0 ? lat + (existingCount * 0.00001) : lat;
                        const offsetLng = existingCount > 0 ? lng + (existingCount * 0.00001) : lng;

                        const { driver, group } = state.activeColumn ? 
                            parseCombined(row[state.activeColumn]) : 
                            { driver: '', group: null };
                        
                        let color = state.colorMap[driver] || '#999999';
                        
                        if (driver.toLowerCase().includes('unassigned')) {
                            color = '#000000';
                        }
                        
                        const dogId = getDogId(row);
                        const isInSelection = dogId && state.selectedMarkers.has(dogId);
                        const hasCallout = row['Callout'] && row['Callout'].trim();
                        
                        // Calculate group counts for this driver
                        let driverGroupCounts = { 1: 0, 2: 0, 3: 0 };
                        if (driver && state.allData && state.activeColumn) {
                            state.allData.forEach(dataRow => {
                                if (!dataRow || !dataRow[state.activeColumn]) return;
                                
                                const dataColumnValue = dataRow[state.activeColumn].trim();
                                if (!dataColumnValue || dataColumnValue === '') return;
                                const dataColumnValueLower = dataColumnValue.toLowerCase();
                                if (dataColumnValueLower === 'cancel' || 
                                    dataColumnValueLower === 'lmcancel' || 
                                    dataColumnValueLower === 'lm cancel' ||
                                    dataColumnValueLower === 'cancelled' ||
                                    dataColumnValueLower === 'lm cancelled') return;
                                
                                const { driver: dataDriver, group: dataGroup } = parseCombined(dataColumnValue);
                                if (dataDriver !== driver) return;
                                
                                const dogCount = parseInt(dataRow['Number of Dogs'] || '1') || 1;
                                
                                if (dataGroup !== null) {
                                    if (typeof dataGroup === 'string' && dataGroup.length > 1) {
                                        dataGroup.split('').forEach(g => {
                                            const groupNum = parseInt(g);
                                            if (groupNum >= 1 && groupNum <= 3) {
                                                driverGroupCounts[groupNum] += dogCount;
                                            }
                                        });
                                    } else if (typeof dataGroup === 'number' && dataGroup >= 1 && dataGroup <= 3) {
                                        driverGroupCounts[dataGroup] += dogCount;
                                    }
                                }
                            });
                        }
                        
                        // Format tooltip
                        const driverDisplay = driver || 'No Driver';
                        const groupDisplay = group ? (row[state.activeColumn] ? row[state.activeColumn].split(':')[1] : group) : '?';
                        const dogNameDisplay = row['Dog Name'] || 'Unknown';
                        const countValue = row['Count'] || '';
                        const notesValue = row['Notes'] || '';
                        
                        let tooltipHtml = `<div style="text-align: center;"><strong>${escapeHtml(driverDisplay)}:${escapeHtml(groupDisplay)}</strong>`;
                        if (countValue && countValue.toString().trim() !== '') {
                            tooltipHtml += `  <span style="color: #ff6b6b; font-weight: bold;">(${escapeHtml(countValue)})</span>`;
                        }
                        
                        const totalDogs = driverGroupCounts[1] + driverGroupCounts[2] + driverGroupCounts[3];
                        if (totalDogs > 0) {
                            tooltipHtml += `<br/><span style="color: #ffd700; font-size: 14px;">${driverGroupCounts[1]}, ${driverGroupCounts[2]}, ${driverGroupCounts[3]}</span>`;
                        }
                        
                        tooltipHtml += `<br/>${escapeHtml(dogNameDisplay)}`;
                        
                        if (notesValue && notesValue.toString().trim() !== '') {
                            tooltipHtml += `<br/><span style="font-style: italic; color: white;">${escapeHtml(notesValue)}</span>`;
                        }
                        
                        tooltipHtml += `</div>`;
                        
                        const marker = L.marker([offsetLat, offsetLng], {
                            icon: createMarkerIcon(color, false, 'group', group, isInSelection, row['Dog Name'], hasCallout),
                            riseOnHover: true
                        });

                        marker.addTo(state.map);
                        
                        marker.bindTooltip(tooltipHtml, {
                            permanent: false,
                            direction: 'top',
                            offset: [0, -15],
                            className: 'custom-tooltip',
                            opacity: 0.95
                        });

                        marker._rowData = row;
                        
                        const { group: markerGroup } = state.activeColumn && row[state.activeColumn] ? 
                            parseCombined(row[state.activeColumn]) : 
                            { driver: '', group: null };
                        
                        const markerData = {marker, row, index: row['_rowIndex'] ?? state.allData.indexOf(row), group: markerGroup};
                        
                        if (dogId) {
                            state.markerLookup.set(dogId, markerData);
                        }
                        
                        marker.on('click', function(e) {
                            try {
                                if (state.selectionMode) {
                                    e.originalEvent.stopPropagation();
                                    const dogId = getDogId(row);
                                    if (!dogId) return;
                                    
                                    if (state.selectedMarkers.has(dogId)) {
                                        state.selectedMarkers.delete(dogId);
                                    } else if (state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                                        state.selectedMarkers.add(dogId);
                                    } else {
                                        showNotification(`Maximum ${CONFIG.MAX_SELECTION} markers can be selected`, 'error');
                                        return;
                                    }
                                    
                                    updateSelectedMarkersDisplay();
                                    updateBulkEditPanel();
                                } else {
                                    const validIndex = row['_rowIndex'] ?? state.allData.indexOf(row);
                                    const { group: clickGroup } = state.activeColumn && row[state.activeColumn] ? 
                                        parseCombined(row[state.activeColumn]) : 
                                        { driver: '', group: null };
                                    selectMarker(marker, row, validIndex, clickGroup);
                                }
                            } catch (clickError) {
                                console.error('Error handling marker click:', clickError);
                                showNotification('Error handling marker click', 'error');
                            }
                        });

                        state.markers.push(markerData);
                        
                    } catch (markerError) {
                        console.warn('Error creating marker:', markerError);
                    }
                });

                updateLegend();
                
                // Re-add field markers (they were cleared in updateMap)
                addFieldMarkers();
                
                // Fit bounds if we have markers
                if (state.markers.length > 0 && state.markers.length < 100) {
                    const group = L.featureGroup(state.markers.map(m => m.marker));
                    state.map.fitBounds(group.getBounds().pad(0.1));
                }
                
            } catch (error) {
                console.error('Error in updateMap:', error);
                showNotification('Error updating map display', 'error');
            }
        }

        // ==================== SELECTION MODE ====================
        function toggleSelectionMode() {
            state.selectionMode = !state.selectionMode;
            
            const btn = document.getElementById('selectionModeBtn');
            const clearBtn = document.getElementById('clearSelectionBtn');
            
            if (!btn || !clearBtn) return;
            
            if (state.selectionMode) {
                btn.textContent = 'üéØ Exit Select Mode';
                btn.classList.add('selection-mode-active');
                clearBtn.style.display = 'inline-block';
                
                enableDrawingTools();
                showNotification('Draw a polygon around markers to select them', 'info');
            } else {
                btn.textContent = 'üéØ Select Mode';
                btn.classList.remove('selection-mode-active');
                clearBtn.style.display = 'none';
                
                disableDrawingTools();
                clearSelection();
            }
        }

        function enableDrawingTools() {
            if (!state.map || !L.Control.Draw) {
                console.error('Leaflet.draw library not loaded');
                return;
            }
            
            try {
                if (!state.drawnItems) {
                    state.drawnItems = new L.FeatureGroup();
                    state.map.addLayer(state.drawnItems);
                }

                if (!state.drawControl) {
                    state.drawControl = new L.Control.Draw({
                        position: 'topleft',
                        edit: {
                            featureGroup: state.drawnItems,
                            remove: true,
                            edit: true
                        },
                        draw: {
                            polygon: {
                                allowIntersection: false,
                                drawError: {
                                    color: '#e1e100',
                                    message: '<strong>Error!</strong> Shape intersects itself!'
                                },
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                },
                                showArea: true
                            },
                            rectangle: {
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                }
                            },
                            circle: false,
                            marker: false,
                            circlemarker: false,
                            polyline: false
                        }
                    });
                    
                    state.map.addControl(state.drawControl);
                }

                state.map.off('draw:created').on('draw:created', onDrawCreated);
                state.map.off('draw:deleted').on('draw:deleted', onDrawDeleted);
                state.map.off('draw:edited').on('draw:edited', onDrawEdited);
                
            } catch (error) {
                console.error('Error enabling drawing tools:', error);
            }
        }

        function disableDrawingTools() {
            try {
                if (state.map) {
                    state.map.off('draw:created');
                    state.map.off('draw:deleted');
                    state.map.off('draw:edited');
                }

                if (state.drawControl && state.map && state.map.hasLayer(state.drawControl)) {
                    state.map.removeControl(state.drawControl);
                }
                state.drawControl = null;

                if (state.drawnItems) {
                    state.drawnItems.clearLayers();
                    if (state.map && state.map.hasLayer(state.drawnItems)) {
                        state.map.removeLayer(state.drawnItems);
                    }
                }
                state.drawnItems = null;

            } catch (error) {
                console.error('Error disabling drawing tools:', error);
            }
        }

        function onDrawCreated(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            const layer = e.layer;
            if (!layer) return;
            
            try {
                state.drawnItems.addLayer(layer);
                
                selectMarkersInPolygonAdditive(layer);
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
                
                const shapeCount = state.drawnItems.getLayers().length;
                if (shapeCount > 10) {
                    showNotification('Maximum 10 selection areas allowed', 'error');
                    const layers = state.drawnItems.getLayers();
                    if (layers.length > 0) {
                        state.drawnItems.removeLayer(layers[0]);
                    }
                }
                
            } catch (error) {
                console.error('Error in onDrawCreated:', error);
            }
        }

        function onDrawDeleted(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawDeleted:', error);
            }
        }

        function onDrawEdited(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawEdited:', error);
            }
        }

        function selectMarkersInPolygonAdditive(polygon) {
            if (!state.selectionMode || !state.markers || state.markers.length === 0) return;
            
            const bounds = polygon.getBounds();
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                const latLng = markerData.marker.getLatLng();
                if (!latLng) return;
                
                if (!bounds.contains(latLng)) return;
                
                let isInside = false;
                try {
                    if (polygon instanceof L.Polygon || polygon instanceof L.Rectangle) {
                        const latlngs = polygon.getLatLngs();
                        if (latlngs && latlngs.length > 0) {
                            const outerRing = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
                            if (outerRing && outerRing.length >= 3) {
                                isInside = isPointInPolygon(latLng, outerRing);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking polygon intersection:', error);
                    return;
                }
                
                if (isInside) {
                    const dogId = getDogId(markerData.row);
                    if (dogId && state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                        state.selectedMarkers.add(dogId);
                    }
                }
            });
        }

        function updateSelectedMarkersDisplay() {
            if (!state.markers || state.markers.length === 0) return;
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                try {
                    const dogId = getDogId(markerData.row);
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    const isSelected = state.selectedMarker === markerData.marker;
                    
                    const { driver, group } = state.activeColumn && markerData.row[state.activeColumn] ? 
                        parseCombined(markerData.row[state.activeColumn]) : 
                        { driver: '', group: null };
                        
                    let color = state.colorMap[driver] || '#999999';
                    
                    if (driver.toLowerCase().includes('unassigned')) {
                        color = '#000000';
                    }
                    
                    const newIcon = createMarkerIcon(color, isSelected, 'group', group, isInSelection, markerData.row['Dog Name'], markerData.row['Callout'] && markerData.row['Callout'].trim());
                    markerData.marker.setIcon(newIcon);
                } catch (error) {
                    console.error('Error updating marker display:', error);
                }
            });
            
            if (state.selectionMode) {
                showNotification(`Selected ${state.selectedMarkers.size} markers`, 'info', 1000);
            }
        }

        function updateBulkEditPanel() {
            const panel = document.getElementById('bulkEditPanel');
            if (!panel) return;
            
            if (state.selectedMarkers.size === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            try {
                const selectedRows = [];
                for (const dogId of state.selectedMarkers) {
                    const markerData = state.markerLookup.get(dogId);
                    if (markerData && markerData.row) {
                        selectedRows.push(markerData.row);
                    }
                }
                
                const previewHtml = selectedRows.slice(0, 10).map(row => {
                    const dogName = escapeHtml(row['Dog Name'] || 'Unknown');
                    const combined = state.activeColumn ? (row[state.activeColumn] || '') : '';
                    const { driver } = parseCombined(combined);
                    const driverDisplay = driver || 'No Driver';
                    return `<div class="selected-dog-item">${dogName} - ${driverDisplay}</div>`;
                }).join('');
                
                const moreText = selectedRows.length > 10 ? 
                    `<div class="selected-dog-item">... and ${selectedRows.length - 10} more</div>` : '';
                
                panel.innerHTML = `
                    <div class="bulk-edit-panel">
                        <div class="bulk-edit-header">
                            <h4>üéØ Bulk Edit Selection</h4>
                            <span class="selected-count">${state.selectedMarkers.size} selected</span>
                        </div>
                        <div class="selected-dogs-preview">
                            ${previewHtml}
                            ${moreText}
                        </div>
                        <div class="bulk-edit-controls">
                            <div style="display: flex; gap: 8px; width: 100%; margin-bottom: 8px;">
                                <div style="flex: 2;">
                                    <input type="text" id="bulkDriverInput" class="bulk-edit-input" 
                                           placeholder="Driver name (e.g., John)"
                                           title="Driver name for all selected markers"
                                           autocomplete="off" 
                                           style="margin: 0;" />
                                </div>
                                <div style="flex: 1;">
                                    <input type="text" id="bulkGroupInput" class="bulk-edit-input" 
                                           placeholder="Group (e.g., 1)"
                                           title="Group for all selected markers"
                                           autocomplete="off" 
                                           style="margin: 0;" />
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" onclick="bulkUpdateSelected()" 
                                        id="bulkUpdateBtn" style="flex: 1;">üíæ Update All</button>
                                <button class="btn btn-secondary" onclick="clearSelection()" style="flex: 1;">‚úñÔ∏è Cancel</button>
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #999; margin-top: 5px;">
                            Enter driver name and group separately. Both will be combined as "Driver:Group"
                        </div>
                    </div>
                `;
                
                setTimeout(() => {
                    const driverInput = document.getElementById('bulkDriverInput');
                    if (driverInput) driverInput.focus();
                }, 100);
                
            } catch (error) {
                console.error('Error updating bulk edit panel:', error);
                panel.innerHTML = '<div class="error-message">Error loading selection panel</div>';
            }
        }

        function clearSelection() {
            state.selectedMarkers.clear();
            updateSelectedMarkersDisplay();
            updateBulkEditPanel();
            
            if (state.drawnItems) {
                state.drawnItems.clearLayers();
            }
            
            if (state.selectionMode) {
                showNotification('Selection cleared', 'info', 1000);
            }
        }

        // ==================== MARKER SELECTION ====================
        function selectMarker(marker, row, index, group) {
            if (!marker || !row || !state.map) {
                console.error('Invalid parameters for selectMarker');
                return;
            }
            
            try {
                // Clear previous selection
                if (state.selectedMarker && state.selectedMarker !== marker) {
                    const prevData = state.markers.find(m => m && m.marker === state.selectedMarker);
                    if (prevData) {
                        try {
                            const { driver: prevDriver, group: prevGroup } = state.activeColumn && prevData.row[state.activeColumn] ? 
                                parseCombined(prevData.row[state.activeColumn]) : 
                                { driver: '', group: null };
                                
                            let color = state.colorMap[prevDriver] || '#999999';
                            
                            if (prevDriver.toLowerCase().includes('unassigned')) {
                                color = '#000000';
                            }
                            
                            const dogId = getDogId(prevData.row);
                            const isInSelection = dogId && state.selectedMarkers.has(dogId);
                            state.selectedMarker.setIcon(createMarkerIcon(color, false, 'group', prevGroup, isInSelection, prevData.row['Dog Name'], prevData.row['Callout'] && prevData.row['Callout'].trim()));
                        } catch (clearError) {
                            console.warn('Error clearing previous marker:', clearError);
                        }
                    }
                }

                state.selectedMarker = marker;
                state.selectedRow = row;
                
                // Update marker appearance
                try {
                    const { driver, group } = state.activeColumn && row[state.activeColumn] ? 
                        parseCombined(row[state.activeColumn]) : 
                        { driver: '', group: null };
                    
                    let color = state.colorMap[driver] || '#999999';
                    
                    if (driver.toLowerCase().includes('unassigned')) {
                        color = '#000000';
                    }
                    
                    const dogId = getDogId(row);
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    marker.setIcon(createMarkerIcon(color, true, 'group', group, isInSelection, row['Dog Name'], row['Callout'] && row['Callout'].trim()));
                } catch (iconError) {
                    console.warn('Error updating marker icon:', iconError);
                }

                // Update details panel
                updateDetailsPanel(row, index);
                
            } catch (error) {
                console.error('Error in selectMarker:', error);
                showNotification('Error selecting marker', 'error');
            }
        }

        function updateDetailsPanel(row, index) {
            const detailsContent = document.getElementById('detailsContent');
            if (!detailsContent) return;
            
            try {
                const actualIndex = row['_rowIndex'] ?? state.allData.indexOf(row);
                
                const currentCombined = state.activeColumn ? (row[state.activeColumn] || '') : '';
                const { driver: currentDriver, group: currentGroup } = parseCombined(currentCombined);
                
                const dogName = row['Dog Name'] || 'Unknown';
                const address = row['Address'] || '';
                const capacity = row['Capacity'] || '';
                const callout = row['Callout'] || '';
                const dogId = row['Dog ID'] || '';
                
                let infoHtml = '';
                
                infoHtml += `<div style="font-weight: bold; color: #333; margin-bottom: 8px; font-size: 14px; text-align: center; padding: 6px 8px; background: #f8f9fa; border-radius: 4px;">
                    ${escapeHtml(dogName)}
                </div>`;
                
                infoHtml += `<div style="text-align: center; margin-bottom: 6px; font-size: 11px; color: #666;">
                    Column: ${escapeHtml(state.activeColumn)}
                </div>`;
                
                if (dogId) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 11px; color: #999; text-align: center;">
                        ID: ${escapeHtml(dogId)}
                    </div>`;
                }
                
                if (address) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">
                        ${escapeHtml(address)}
                    </div>`;
                }
                
                if (capacity) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">
                        <strong>Capacity:</strong> ${escapeHtml(capacity)}
                    </div>`;
                }
                
                if (callout) {
                    infoHtml += `<div style="background: #fff3cd; padding: 6px; border-radius: 4px; margin-bottom: 6px;">
                        <strong style="color: #856404;">CALLOUT:</strong> 
                        <span style="color: #856404;">${escapeHtml(callout)}</span>
                    </div>`;
                }
                
                // Convert group back to display format (show original group string if available)
                let groupDisplayValue = '';
                if (currentGroup !== null) {
                    // Try to extract the original group portion from the combined field
                    if (currentCombined.includes(':')) {
                        groupDisplayValue = currentCombined.split(':')[1] || '';
                    } else {
                        groupDisplayValue = currentGroup.toString();
                    }
                }
                
                const detailsHtml = `
                    ${infoHtml}
                    
                    <div style="border-top: 1px solid #dee2e6; padding-top: 8px; margin-top: 8px;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                            <div style="flex: 2;">
                                <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Driver Name:</label>
                                <input type="text" id="editDriver" value="${escapeHtml(currentDriver || '')}" 
                                       placeholder="Driver name (e.g., John)"
                                       style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                       autocomplete="off">
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Group:</label>
                                <input type="text" id="editGroup" value="${escapeHtml(groupDisplayValue)}" 
                                       placeholder="Group (e.g., 1, 2DD2)"
                                       style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                       autocomplete="off">
                            </div>
                        </div>
                        
                        <div style="font-size: 10px; color: #999; margin-bottom: 8px;">
                            Group examples: 1, 2, 3, 1DD1, 2F2, 1&2, 123
                        </div>
                        
                        <div style="display: flex; gap: 4px;">
                            <button class="btn btn-primary" onclick="saveMarkerData()" 
                                    id="saveBtn" style="flex: 1; padding: 6px 8px; font-size: 12px;">
                                üíæ Save
                            </button>
                            <button class="btn btn-secondary" onclick="cancelEdit()" 
                                    style="flex: 1; padding: 6px 8px; font-size: 12px;">
                                ‚úñÔ∏è Cancel
                            </button>
                        </div>
                    </div>
                `;
                
                detailsContent.innerHTML = detailsHtml;
                
                setTimeout(() => {
                    const driverInput = document.getElementById('editDriver');
                    const groupInput = document.getElementById('editGroup');
                    
                    if (driverInput) {
                        driverInput.focus();
                        driverInput.select();
                        
                        // Add keyboard handlers to both fields
                        [driverInput, groupInput].forEach(input => {
                            if (input) {
                                input.addEventListener('keydown', function(e) {
                                    if (e.key === 'Enter') {
                                        e.preventDefault();
                                        saveMarkerData();
                                    } else if (e.key === 'Escape') {
                                        e.preventDefault();
                                        cancelEdit();
                                    } else if (e.key === 'Tab' && input === driverInput) {
                                        // Tab from driver to group field
                                        setTimeout(() => groupInput?.focus(), 0);
                                    }
                                });
                            }
                        });
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error updating details panel:', error);
                detailsContent.innerHTML = '<div class="error-message">Error showing details</div>';
            }
        }

        // ==================== LEGEND ====================
        function updateLegend() {
            const legendContent = document.getElementById('legendContent');
            if (!legendContent) return;
            
            try {
                const sortedEntries = Object.entries(state.colorMap).sort(([a], [b]) => a.localeCompare(b));
                const legendItems = [];
                
                sortedEntries.forEach(([key, color]) => {
                    if (!key || !color) return;
                    
                    const isActive = state.currentFilter === key;
                    let displayText = escapeHtml(key);
                    
                    // Add group counts for drivers
                    if (state.allData && state.allData.length > 0 && state.activeColumn) {
                        const groupCounts = { 1: 0, 2: 0, 3: 0 };
                        
                        state.allData.forEach(row => {
                            if (!row || !row[state.activeColumn]) return;
                            
                            const columnValue = row[state.activeColumn].trim();
                            if (!columnValue || columnValue === '') return;
                            const columnValueLower = columnValue.toLowerCase();
                            if (columnValueLower === 'cancel' || 
                                columnValueLower === 'lmcancel' || 
                                columnValueLower === 'lm cancel' ||
                                columnValueLower === 'cancelled' ||
                                columnValueLower === 'lm cancelled') return;
                            
                            const { driver, group } = parseCombined(columnValue);
                            if (driver !== key) return;
                            
                            const dogCount = parseInt(row['Number of Dogs'] || '1') || 1;
                            
                            if (group !== null) {
                                if (typeof group === 'string' && group.length > 1) {
                                    group.split('').forEach(g => {
                                        const groupNum = parseInt(g);
                                        if (groupNum >= 1 && groupNum <= 3) {
                                            groupCounts[groupNum] += dogCount;
                                        }
                                    });
                                } else if (typeof group === 'number' && group >= 1 && group <= 3) {
                                    groupCounts[group] += dogCount;
                                }
                            }
                        });
                        
                        const total = groupCounts[1] + groupCounts[2] + groupCounts[3];
                        if (total > 0) {
                            displayText += ` (${groupCounts[1]}, ${groupCounts[2]}, ${groupCounts[3]})`;
                        }
                    }
                    
                    const dataKey = escapeHtml(key);
                    const safeKey = key.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\\/g, '\\\\');
                    
                    legendItems.push(`
                        <div class="legend-item ${isActive ? 'active' : ''}" 
                             onclick="filterByCategory('${safeKey}')"
                             role="button"
                             tabindex="0"
                             aria-label="Filter by ${dataKey}"
                             aria-pressed="${isActive}">
                            <div class="legend-color" style="background-color: ${color}"></div>
                            <span class="legend-text">${displayText}</span>
                            <input type="color" class="color-picker" value="${color}" 
                                   data-category="${dataKey}"
                                   aria-label="Change color for ${dataKey}"
                                   onclick="event.stopPropagation()" />
                        </div>
                    `);
                });
                
                legendContent.innerHTML = legendItems.join('') || '<div class="no-selection">No drivers found</div>';
                
                // Add color picker handlers
                const pickers = legendContent.querySelectorAll('.color-picker');
                pickers.forEach(picker => {
                    picker.addEventListener('change', function(e) {
                        e.stopPropagation();
                        const categoryName = this.getAttribute('data-category');
                        if (categoryName) {
                            changeCustomColor(categoryName, this.value);
                        }
                    });
                    picker.addEventListener('click', e => e.stopPropagation());
                });
                
            } catch (error) {
                console.error('Error updating legend:', error);
                legendContent.innerHTML = '<div class="error-message">Error loading legend</div>';
            }
        }

        // ==================== EVENT HANDLERS ====================
        function toggleGroupFilter(group) {
            const btn = document.getElementById(`group${group}Btn`);
            if (!btn) return;
            
            const index = state.activeGroups.indexOf(group);
            
            if (index > -1) {
                if (state.activeGroups.length > 1) {
                    state.activeGroups.splice(index, 1);
                    btn.classList.remove('active');
                    btn.setAttribute('aria-pressed', 'false');
                } else {
                    showNotification('At least one group must remain active', 'error');
                    return;
                }
            } else {
                state.activeGroups.push(group);
                state.activeGroups.sort();
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
            }
            
            updateMap();
        }

        function filterByCategory(category) {
            state.currentFilter = state.currentFilter === category ? null : category;
            updateMap();
            
            if (state.currentFilter) {
                showNotification(`Filtering by: ${category}`, 'info', 2000);
            } else {
                showNotification('Filter cleared', 'info', 2000);
            }
        }

        function clearFilter() {
            state.currentFilter = null;
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            updateMap();
            showNotification('All filters cleared', 'info', 2000);
        }

        function resetColors() {
            if (Object.keys(state.customColors).length === 0) {
                showNotification('No custom colors to reset', 'info');
                return;
            }
            
            console.log('Resetting all custom colors');
            state.customColors = {};
            assignDriverColors();
            updateMap();
            showNotification('All custom colors reset', 'success');
        }

        function togglePanel() {
            const panel = document.getElementById('leftPanel');
            const toggle = document.getElementById('panelToggle');
            const icon = document.getElementById('panelToggleIcon');
            
            if (panel && toggle && icon) {
                panel.classList.toggle('open');
                icon.textContent = panel.classList.contains('open') ? '‚ñ∂' : '‚óÄ';
            }
        }

        // ==================== SAVE FUNCTIONS ====================
        async function saveMarkerData() {
            const editDriverInput = document.getElementById('editDriver');
            const editGroupInput = document.getElementById('editGroup');
            const saveBtn = document.getElementById('saveBtn');
            
            if (!editDriverInput || !editGroupInput) {
                showNotification('Error: Edit fields not found', 'error');
                return;
            }
            
            const driverValue = editDriverInput.value.trim();
            const groupValue = editGroupInput.value.trim();
            
            // Combine driver and group back into the expected format
            let newCombinedValue = '';
            if (driverValue && groupValue) {
                newCombinedValue = `${driverValue}:${groupValue}`;
            } else if (driverValue) {
                newCombinedValue = driverValue; // Just driver, no group
            } else if (groupValue) {
                newCombinedValue = `:${groupValue}`; // Just group, no driver (unusual but possible)
            }
            // If both are empty, newCombinedValue stays empty
            
            if (!state.selectedRow || !state.activeColumn) {
                showNotification('Error: No row or column selected', 'error');
                return;
            }

            try {
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '‚è≥ Saving...';
                }
                
                const oldCombined = state.selectedRow[state.activeColumn] || '';
                
                const sheetRowIndex = getSheetRowIndex(state.selectedRow);
                
                if (sheetRowIndex === -1) {
                    throw new Error('Could not determine row index');
                }
                
                console.log('Saving to sheet row:', sheetRowIndex, 'column:', state.activeColumn, 
                           'driver:', driverValue, 'group:', groupValue, 'combined:', newCombinedValue);
                
                state.selectedRow[state.activeColumn] = newCombinedValue;
                
                const dogId = getDogId(state.selectedRow);
                const markerData = state.markerLookup.get(dogId);
                if (markerData) {
                    // Parse the new combined value to get the processed group
                    const { driver, group } = parseCombined(newCombinedValue);
                    markerData.group = group;
                    
                    let color = state.colorMap[driver] || '#999999';
                    
                    if (driver.toLowerCase().includes('unassigned')) {
                        color = '#000000';
                    }
                    
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    const hasCallout = state.selectedRow['Callout'] && state.selectedRow['Callout'].trim();
                    
                    const newIcon = createMarkerIcon(color, true, 'group', markerData.group, isInSelection, state.selectedRow['Dog Name'], hasCallout);
                    markerData.marker.setIcon(newIcon);
                }
                
                assignDriverColors();
                updateMap();
                
                showNotification('Saving to Google Sheets...', 'info', 1000);
                
                const payload = {
                    action: 'updateRow',
                    rowIndex: sheetRowIndex,
                    updatedData: {}
                };
                payload.updatedData[state.activeColumn] = newCombinedValue;
                
                await callAppsScript(payload);
                
                showNotification('‚úÖ Data updated in Google Sheets!', 'success', 2000);
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = 'üíæ Save';
                }
                
            } catch (error) {
                console.error('Error in saveMarkerData:', error);
                showNotification(`Error saving: ${error.message}`, 'error');
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = 'üíæ Save';
                }
                
                if (state.selectedRow && state.activeColumn && typeof oldCombined !== 'undefined') {
                    state.selectedRow[state.activeColumn] = oldCombined;
                    assignDriverColors();
                    updateMap();
                }
            }
        }

        async function saveDriverName() {
            return saveMarkerData();
        }

        async function bulkUpdateSelected() {
            if (!state.selectionMode) {
                showNotification('Not in selection mode', 'error');
                return;
            }
            
            const bulkDriverInput = document.getElementById('bulkDriverInput');
            const bulkGroupInput = document.getElementById('bulkGroupInput');
            const bulkBtn = document.getElementById('bulkUpdateBtn');
            
            if (!bulkDriverInput || !bulkGroupInput || !state.activeColumn) {
                showNotification('Interface not ready. Please try again.', 'error');
                return;
            }
            
            const driverValue = bulkDriverInput.value.trim();
            const groupValue = bulkGroupInput.value.trim();
            
            // Combine the values
            let newCombinedValue = '';
            if (driverValue && groupValue) {
                newCombinedValue = `${driverValue}:${groupValue}`;
            } else if (driverValue) {
                newCombinedValue = driverValue;
            } else if (groupValue) {
                newCombinedValue = `:${groupValue}`;
            }
            
            if (!newCombinedValue) {
                showNotification('Please enter at least a driver name or group', 'error');
                bulkDriverInput.focus();
                return;
            }
            
            if (state.selectedMarkers.size === 0) {
                showNotification('No markers selected', 'error');
                return;
            }
            
            try {
                const validSelectedRows = [];
                const sheetRowIndices = [];
                
                for (const dogId of state.selectedMarkers) {
                    const markerData = state.markerLookup.get(dogId);
                    if (markerData && markerData.row) {
                        const sheetRowIndex = getSheetRowIndex(markerData.row);
                        if (sheetRowIndex !== -1) {
                            validSelectedRows.push(markerData.row);
                            sheetRowIndices.push(sheetRowIndex);
                        }
                    }
                }
                
                if (validSelectedRows.length === 0) {
                    showNotification('No valid markers selected', 'error');
                    return;
                }
                
                if (!confirm(`Update ${validSelectedRows.length} dogs with: "${newCombinedValue}"?`)) {
                    return;
                }
                
                if (bulkBtn) {
                    bulkBtn.disabled = true;
                    bulkBtn.innerHTML = '‚è≥ Updating...';
                }
                
                const oldValues = validSelectedRows.map(row => ({
                    row: row,
                    oldValue: row[state.activeColumn] || ''
                }));
                
                validSelectedRows.forEach(row => {
                    row[state.activeColumn] = newCombinedValue;
                });
                
                assignDriverColors();
                updateMap();
                clearSelection();
                
                showNotification(`Saving ${validSelectedRows.length} updates to Google Sheets...`, 'info');
                
                const updates = sheetRowIndices.map(sheetRowIndex => {
                    const updateData = {};
                    updateData[state.activeColumn] = newCombinedValue;
                    return {
                        rowIndex: sheetRowIndex,
                        updatedData: updateData
                    };
                });
                
                console.log('Bulk updating rows:', sheetRowIndices, 'with combined value:', newCombinedValue);
                
                const payload = {
                    action: 'bulkUpdate',
                    updates: updates
                };
                
                await callAppsScript(payload);
                
                showNotification(`‚úÖ Successfully updated ${validSelectedRows.length} dogs in Google Sheets!`, 'success', 3000);
                
                if (bulkBtn) {
                    bulkBtn.disabled = false;
                    bulkBtn.innerHTML = 'üíæ Update All';
                }
                
            } catch (error) {
                console.error('Bulk update error:', error);
                showNotification(`Error during bulk update: ${error.message}`, 'error');
                
                if (bulkBtn) {
                    bulkBtn.disabled = false;
                    bulkBtn.innerHTML = 'üíæ Update All';
                }
                
                if (oldValues && state.activeColumn) {
                    oldValues.forEach(({row, oldValue}) => {
                        row[state.activeColumn] = oldValue;
                    });
                    assignDriverColors();
                    updateMap();
                }
            }
        }

        function cancelEdit() {
            if (state.selectedMarker && state.selectedRow) {
                const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);
                if (markerData) {
                    const index = state.selectedRow['_rowIndex'] ?? state.allData.indexOf(state.selectedRow);
                    const { group } = state.activeColumn && state.selectedRow[state.activeColumn] ? 
                        parseCombined(state.selectedRow[state.activeColumn]) : 
                        { driver: '', group: null };
                    selectMarker(state.selectedMarker, state.selectedRow, index, group);
                }
            }
        }

        // ==================== INITIALIZATION ====================
        const debouncedUpdateMap = debounce(updateMap, CONFIG.DEBOUNCE_DELAY);

        function initializeApp() {
            try {
                console.log('DOM loaded, initializing application...');
                
                // Check browser compatibility
                const requiredFeatures = [
                    'Promise' in window,
                    'fetch' in window,
                    'Map' in window,
                    'Set' in window,
                    'requestAnimationFrame' in window
                ];
                
                const missingFeatures = requiredFeatures.filter((feature, index) => {
                    const featureName = ['Promise', 'fetch', 'Map', 'Set', 'requestAnimationFrame'][index];
                    if (!eval(feature)) {
                        console.error(`Missing required feature: ${featureName}`);
                        return true;
                    }
                    return false;
                });
                
                if (missingFeatures.length > 0) {
                    showNotification('Your browser is missing required features. Please use a modern browser.', 'error', 0);
                    return;
                }
                
                // Initialize map
                initMap();
                
                // Load initial data
                loadData();
                
                // Test Apps Script connection after a short delay
                setTimeout(() => testAppsScriptConnection(), 2000);
                
                // Setup event listeners
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', debouncedUpdateMap);
                    searchInput.addEventListener('search', debouncedUpdateMap);
                }
                
                // Group filter buttons
                document.getElementById('group1Btn')?.addEventListener('click', () => toggleGroupFilter(1));
                document.getElementById('group2Btn')?.addEventListener('click', () => toggleGroupFilter(2));
                document.getElementById('group3Btn')?.addEventListener('click', () => toggleGroupFilter(3));
                
                // Other buttons
                document.getElementById('selectionModeBtn')?.addEventListener('click', toggleSelectionMode);
                document.getElementById('clearSelectionBtn')?.addEventListener('click', clearSelection);
                document.getElementById('resetColorsBtn')?.addEventListener('click', resetColors);
                document.getElementById('showAllBtn')?.addEventListener('click', clearFilter);
                document.getElementById('panelToggle')?.addEventListener('click', togglePanel);
                document.getElementById('testConnectionBtn')?.addEventListener('click', testAppsScriptConnection);
                
                // Add keyboard shortcuts
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        if (state.selectionMode) {
                            toggleSelectionMode();
                        } else if (state.selectedMarker) {
                            state.selectedMarker = null;
                            state.selectedRow = null;
                            updateMap();
                            const detailsContent = document.getElementById('detailsContent');
                            if (detailsContent) {
                                detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';
                            }
                        }
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                        e.preventDefault();
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.select();
                        }
                    }
                });
                
                console.log('Application initialized successfully');
                console.log('Dog Walking Map v2.8 - With Fields Tab Support');
                console.log('Now loading field locations from the "Fields" tab');
                console.log('Fields display as black diamonds and are non-editable');
                
            } catch (error) {
                console.error('Error during application initialization:', error);
                showNotification('Failed to initialize application', 'error', 0);
            }
        }

        // Global functions for onclick handlers
        window.filterByCategory = filterByCategory;
        window.clearSelection = clearSelection;
        window.saveDriverName = saveDriverName;
        window.saveMarkerData = saveMarkerData;
        window.cancelEdit = cancelEdit;
        window.bulkUpdateSelected = bulkUpdateSelected;
        window.testAppsScriptConnection = testAppsScriptConnection;

        // Global error handler
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            console.error('Stack:', event.error?.stack);
            
            // If error is related to group parsing, provide helpful info
            if (event.error?.message?.includes('group') || event.error?.message?.includes('Group')) {
                console.log('Group parsing tip: Supported business codes are DD, SUB, AA, F');
                console.log('Valid patterns: 1, 2, 3, 1DD1, 2F2, 1&2, 1DD&2, 123, 1SUB23, etc.');
            }
        });

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);

        console.log('Dog Walking Map v2.8 - With Fields Tab Support');
        console.log('The map automatically finds today\'s date column or uses "Combined" as fallback');
        console.log('Hidden: blank entries, "Cancel", "LMCancel", "LM Cancel", "Cancelled", "LM Cancelled"');
        console.log('NEW: Loads field locations from "Fields" tab and displays them as black diamonds');
        console.log('NEW: Split edit fields - separate Driver Name and Group inputs');
    </script>
</body>
</html>
